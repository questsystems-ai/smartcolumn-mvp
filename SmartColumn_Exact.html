<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>SmartColumn — How it works</title>
  <script>
    window.MathJax = {{
      tex: {{ inlineMath: [['$', '$'], ['\\(', '\\)']], displayMath: [['$$','$$'], ['\\[','\\]']] }},
      svg: {{ fontCache: 'global' }}
    }};
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <style>
    body {{ font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
           line-height: 1.45; color: #111; margin: 2.2rem auto; max-width: 860px; padding: 0 1rem; }}
    h1 {{ font-size: 1.75rem; margin: 0 0 0.75rem 0; }}
    h2 {{ font-size: 1.2rem; margin: 1.2rem 0 0.4rem 0; }}
    p  {{ margin: 0.4rem 0 0.6rem 0; }}
    code {{ background: #f6f8fa; padding: 2px 4px; border-radius: 4px; }}
    hr {{ border: 0; border-top: 1px solid #e5e7eb; margin: 1.1rem 0; }}
    .content {{ margin-top: 0.8rem; }}
    .printbtn {{ position: fixed; top: 14px; right: 14px; font-size: 0.9rem; padding: 6px 10px; }}
    @media print {{ .printbtn {{ display: none; }} }}
  </style>
</head>
<body>

<button class="printbtn" onclick="window.print()">Print / Save as PDF</button>
<h1>SmartColumn — How it works</h1>
<div id="md" class="content"></div>

<script>
  const src = `Love this question. Here’s the clean, honest story of what Xu et al. actually did to get the $V_S/V_E$ mapping—and how we turn those “orphan” isocratic volumes into a concrete, quantitatively useful column method.

---

## 1) What the paper actually measured and modeled

**Goal in the paper:** quantify the relationship **TLC → CC** in a way you can compute, not guess.

**How they built the data (silica, PE/EA only):**

* They automated **TLC** to measure **Rf** under many **PE\:EA** compositions, and separately automated **CC** (same stationary phase) to record **UV traces** from which they compute two volumes for the band:

  * **$V_S$**: the **leading edge** (first appearance at the detector)
  * **$V_E$**: the **trailing edge** (when it’s finished eluting)
* Experiments were run at a set of **isocratic** compositions (pure PE, 100:1, 50:1, 10:1, 5:1, 2:1, 1:1, pure EA). No gradients here—just controlled points.

**How they turned this into equations (not a black box):**

* Because the TLC and CC datasets weren’t synchronous, they trained **surrogate models** to predict missing points on a uniform grid (features: molecular fingerprints + simple solvent descriptors).
* Then they ran **symbolic regression** (equation discovery) to get simple, interpretable formulas for the **mean** band start and end at any composition in the PE/EA system:

  $$
  \bar V_S = \frac{r}{a_s \cdot RF + b_s}, \qquad
  \bar V_E = \frac{r}{a_e \cdot RF + b_e}
  $$

  with $r = \frac{\text{PE}}{\text{PE}+\text{EA}}$ and special constants for $r=0$ (pure EA).
* They also discovered a **separation index** heatmap that explains the classic TLC **sweet spot**: keeping the product’s TLC **Rf ≈ 0.2–0.3** at the **same** solvent system improves your odds that two bands will be separable on the column.

**Generalization to other columns and compounds:**

* To move from their 4 g reference column to other sizes, they **recalibrate coefficients** $a_s,b_s,a_e,b_e$ with a **small local dataset** (few-shot fit). They also show a per-compound scaling factor $\varepsilon$ (from simple descriptors) that tightens per-molecule accuracy when available.

**Key takeaways:**

* The paper gives you a **physics-lite oracle** that predicts, at any **isocratic** PE/EA composition and your product’s TLC **Rf**, **when the band will arrive** $(V_S)$ and **when it will finish** $(V_E)$.
* It **does not** design your gradient or tell you how much silica to pack. That’s where we translate their outputs into a usable method.

---

## 2) What $V_S$ and $V_E$ *mean* (and why they differ)

* Real peaks have finite width. At a fixed composition:

  * **$V_S$** marks **arrival** of the band’s front edge.
  * **$V_E$** marks **completion** of elution (tail off).
* In their reference runs, $V_E$ is often \~**2× $V_S$** for typical PE/EA points—i.e., your analyte usually spans roughly a couple of column volumes between first appearance and fully off.

**Practically:** predicting both lets you (a) set a stop line, (b) know if your method is about to be **too late** or **too early**, and (c) size gradient steps in **column-volumes** (CV) with confidence.

---

## 3) How we “tease out” a real method from the isocratic oracle

We keep the lab-friendly workflow you already use and **plug calculus where it counts**.

**Inputs you already have:**

* **TLC solvent** (PE/EA, as **%EA**) and **product Rf** at that TLC solvent. (Rf is only meaningful paired with its TLC composition—exactly as in the paper.)
* **Sample mass**.

**Step A — Size the column in physical units (no guessing):**

1. **Choose silica load** (rule of thumb):
   Standard \~**20×** sample mass; “Conservative” = **30×**, “Efficient” = **15×**. This is your lab policy knob.
2. **Compute packed-bed volume** from **silica bulk density** (e.g., 0.60 g/mL).
   $V_\text{packed} = \frac{\text{silica(g)}}{\rho_\text{bulk}}$ (mL = cm³).
3. **Pick a glass column ID** so the bed sits near **12 cm** (we allow **±2 cm**).
   If your rack has only certain IDs, choose the nearest available and compute the height it implies.
4. **Compute column volume $CV$** as **void volume**, not cylinder volume:
   $CV \approx \varepsilon \cdot V_\text{packed}$ with porosity $\varepsilon \approx 0.40$.
   (This is why “12 cm × 1.3 cm ≈ 6 mL CV”: cylinder \~16 mL, **void \~40%** → \~6–7 mL.)

**Step B — Choose a sensible **final isocratic** near your TLC:**

* We search **TLC %EA ± 10%** in **5% steps** and pick the composition where the oracle’s **$V_E$** lands **near the middle** of a practical band (e.g., **2–6 CV**, center \~4 CV), **without drifting far** from the TLC system.
  That’s the key advance over a “roaming” optimization: it **respects your TLC** and still uses the oracle to avoid a silly late/early elution.

**Step C — Turn CV into a gradient you can run blindfolded:**

* **Pre-equilibration**: 0% EA for **one step volume**.
* **Gradient**: 0 → final %EA in **5% steps**.

  * **Step size (volume)** = **$N$×CV**, where $N$ = **2** (Standard), **3** (Conservative), **1.5** (Efficient).
  * **Final plateau** = **3 × step volume**.
* **Why CV-based?** Because $V_S, V_E$ and your method volumes/time all live in CV. When you change ID, bed height, or load, the math automatically keeps your **time scale** sensible.

**Step D — Make the numbers lab-accurate (3 knobs to calibrate):**

1. **Porosity $\varepsilon$** (void fraction): measure once with a non-retained tracer on your packing, or accept 0.40 ± 0.05.
2. **Coefficient refit** $(a_s,b_s,a_e,b_e)$: run a **few local points** (your column & flow) and refit the constants (as the paper prescribes). This collapses systematic bias from hardware.
3. Optional **compound scaling $\varepsilon_\text{compound}$**: if you want per-analyte sharpening and have structures, fit a single scale factor from one validation run; otherwise skip (the equations are already robust).

**Result:** you get a **column size**, **step volumes**, and **final %EA** that are all **numerically grounded**—and the app annotates where **arrival/finish** should be at both the **TLC** system and the **final isocratic**.

---

## 4) Why this is better than “peg to TLC and hope”

* **TLC-faithful**: we keep the composition **near your TLC** (so your Rf knowledge is relevant) and still quantify when the band will **arrive/finish** at that composition.
* **Geometry-aware**: everything is sized in **CV**, so the same method makes sense whether you’re packing 25 g or 300 g of silica and whether the ID is 2 cm or 6 cm.
* **Quantitatively tuneable**: with a handful of **local CC points**, you can refit the coefficients to your columns and flows and bring prediction error into the **low-teens percent** on $V_E$.
* **Fewer wasteful runs**: the oracle catches “this will be **late** (huge $V_E$) unless you increase %EA a notch” before you pour liters into the column.

---

## 5) A quick worked example (how the numbers emerge)

Say **TLC**: **20% EA**, **Rf = 0.30**, **sample 5 g**.

1. **Load**: Standard 20× → **100 g silica**. Bulk density 0.60 g/mL → packed **167 mL**.
2. **Geometry**: choose ID to keep **\~12 cm** bed; compute **CV ≈ 0.40 × 167 ≈ 67 mL**.
3. **Final isocratic**: search **15–30% EA** in **5% steps**; pick the value where the oracle’s **$V_E$** ≈ **4 CV** (i.e., \~270 mL here), **without** leaving the TLC neighborhood.
4. **Step volumes**: **2 CV ≈ 134 mL** per step (Conservative = **3 CV ≈ 200 mL**, Efficient = **1.5 CV ≈ 100 mL**).
5. **Final plateau**: **3× step** (e.g., **\~400 mL** standard).
6. **Sanity**: the app shows predicted **$V_S/V_E$** at TLC and final %EA, so you know when to expect the band and whether you can shorten or extend.
`;
  document.getElementById("md").innerHTML = marked.parse(src);
  window.addEventListener('load', () => {{ window.MathJax && window.MathJax.typeset(); }});
</script>
</body>
</html>
